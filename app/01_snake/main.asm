            jr      boot
; ------------------------------------------------------------------------------
defw        iKeyb                   ; IRQ#1 KEYBOARD
defw        iRetrace                ; IRQ#2 VRETRACE
; ------------------------------------------------------------------------------
boot:       ld      sp, $8000
            xor     a
            call    cls

            ; Обновить символ
            ld      a, $04
            ld      (color), a      ; Красные яблоки
            ld      de, b_apple     ; Загружаем яблоко* и змею#
            ld      a, '*'
            call    upsym
            ld      a, '#'
            call    upsym
            call    apples          ; Рисуем поле из яблок

            ld      hl, (snake_yx)
            ld      ($A000), hl     ; Хвост=Голова
            ld      a, 1
            ld      (color), a
            ld      a, '#'
            call    pchar

            ei
            halt

; Раз в 60 сек прерывание
; ------------------------------------------------------------------------------
iRetrace:   ld      a, (timer_t)
            inc     a
            cp      15
            call    z, moves
            ld      (timer_t), a
            reti

; Прошел интервал времени, обновить положение головы (пока максимальная длина змеи 128)
; ------------------------------------------------------------------------------

moves:      ; Передвинуть змеюку
            ld      a, (snake_dir)      ; В регистре А будет значение куда двигать (0,1,2,3,4)
            and     a                   ; Проверить на A=0
            ret     z                   ; Если ноль, то никуда не двигать, змеюка отлёживается
            ld      hl, (snake_yx)      ; Взять текущее положение головы змеёныша
            ld      b, 1                ; B=1 для того чтобы X += B добавлять
            dec     a                   ; Если мы уменьшим A--
            jr      z, Xp               ; И там будет 0, значит, A был равен 1 => переходим к X++
            dec     a                   ; Если мы уменьшим A--
            jr      z, Xm               ; Аналогично, если 0, то там было раньше A=2, переходим к X--
            dec     a                   ; Если мы уменьшим A--
            jr      z, Yp               ; То же самое, переходим к Y++
Ym:         ld      a, h                ; В остальном случае считаем что Y--, в A=Y
            and     a                   ; Проверяем Y==0 ?
            jr      nz, Ym2             ; Если нет, то переходим к Y--
            ld      a, $18              ; Если да, то Y=18h
Ym2:        dec     a                   ; И уменьшаем на Y--
            ld      h, a                ; Записываем обратно результат
            jr      Lend                ; К сохранению результата...
Yp:         ld      a, h                ; A=Y
            inc     a                   ; Y++
            cp      $18                 ; Проверить, если Y=18h
            jr      nz, Yp2             ; И если это не так, то это ок
            xor     a                   ; Но если Y=18h, то Y=0
Yp2:        ld      h, a                ; Записать новый Y
            jr      Lend                ; К сохранению результата...
Xm:         ld      b, -1               ; Если X--, то B=-1
Xp:         ld      a, l                ; A=X
            add     b                   ; X+=B
            and     $1F                 ; X&=1Fh ограничиваем ширину
            ld      l, a                ; Записываем X
Lend:       ld      (snake_yx), hl      ; Новое положение головы змейки

            ; Провера наличия яблочка
            call    attra               ; HL=H*32+L+5800h
            ld      a, (hl)             ; Какой атрибут там находится?
            cp      4                   ; Это яблоко?
            jr      z, Eatery           ; Не удалять змее хвост
            cp      2                   ; А если это сама змея?
            jr      z, Gover            ; То геймовер

            ; Удаляем хвост и двигаем змейку
            ld      hl, ($A000)
            xor     a
            ld      (color), a
            call    pchar

            ; Перемещение всей змеи
            ld      bc, $A002
            ld      de, $A000
            ld      hl, (snake_len)
            add     hl, hl
CpRep:      ld      a, h
            or      l
            jr      z, CpOk
            ld      a, (bc)
            ld      (de), a
            inc     bc
            inc     de
            dec     hl
            jr      CpRep

            ; Поместить новое положение головы у змейки
CpOk:       ld      hl, (snake_yx)
            ex      de, hl
            ld      (hl),e
            inc     hl
            ld      (hl),d

            ; Нарисовать голову
            ld      hl, (snake_yx)
            ld      a, 2
            ld      (color), a
            ld      a, '#'
            call    pchar

            xor     a
            ret

; Игра полностью окончена и это просто конец
Gover:      jr      $

            ; Змей сожрал яблоко и стал пухнуть
Eatery:     ld      hl, (snake_len)
            inc     hl
            ld      (snake_len), hl
            ld      de, $A000
            add     hl, hl
            add     hl, de
            ex      de, hl
            jr      CpOk

; Начальное яблочное поле
; ------------------------------------------------------------------------------
apples:     ld      de, f_apple
            ld      b, 16
apples1:    ld      a, (de)
            ld      l, a
            inc     de
            ld      a, (de)
            ld      h, a
            inc     de
            ld      a, '*'
            call    pchar
            djnz    apples1
            ret

; Списки переменных
; ------------------------------------------------------------------------------
snake_yx:   defw    $0905       ; Положение головы
snake_len:  defw    $0000       ; Длина змейки (0 это 1)
snake_dir:  defb    $04         ; Направление движения змейки 0=no, 1=x++, 2=x--, 3=y++, 4=y--
timer_t:    defb    $00
; ------------------------------------------------------------------------------
; for ($i=0;$i<16;$i++) print sprintf("\$%02X%02X,",mt_rand(0,23),mt_rand(0,31));
f_apple:    defw    $1218,$090F,$1705,$1501,$0101,$0E1C,$0911,$0014,$011E,$100B
            defw    $0711,$111F,$0505,$0F1D,$001A,$021F
; ------------------------------------------------------------------------------
b_apple:    defb    %01100110
            defb    %11111111
            defb    %10011111
            defb    %10111111
            defb    %11111111
            defb    %11111111
            defb    %11111111
            defb    %01100110
b_snake:    defb    %00111100
            defb    %01111110
            defb    %11111111
            defb    %11111111
            defb    %11111111
            defb    %11111111
            defb    %01111110
            defb    %00111100
; ------------------------------------------------------------------------------
iKeyb:      reti
; ------------------------------------------------------------------------------
include     "zx.asm"
